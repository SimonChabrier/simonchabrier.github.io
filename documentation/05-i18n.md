# üåê Syst√®me i18n (Internationalisation)

## Vue d'ensemble

J'ai cr√©√© un syst√®me de traduction custom l√©ger bas√© sur des fichiers JSON statiques. Contrairement √† des librairies comme `astro-i18next`, mon syst√®me est minimaliste et adapt√© √† mes besoins.

**Avantages** :
- ü™∂ L√©ger (~100 lignes de code)
- üì¶ Pas de d√©pendance externe
- üéØ Parfaitement adapt√© √† mes besoins
- üöÄ Performance optimale

---

## Architecture

### Fichiers de Traduction

```
public/locales/
‚îú‚îÄ‚îÄ en/
‚îÇ   ‚îú‚îÄ‚îÄ common.json      # Textes g√©n√©raux (theme, locale, keyboard)
‚îÇ   ‚îú‚îÄ‚îÄ components.json  # Composants UI
‚îÇ   ‚îî‚îÄ‚îÄ sections.json    # Sections CV
‚îî‚îÄ‚îÄ fr/
    ‚îú‚îÄ‚îÄ common.json
    ‚îú‚îÄ‚îÄ components.json
    ‚îî‚îÄ‚îÄ sections.json
```

### Fonction Principale : `t()`

**Fichier** : `src/utils/i18n.ts`

**Signature** :
```typescript
function t(
  key: string,              // Format: "namespace:path.to.key"
  options: {
    lng: Locale;            // "fr" | "en"
    [key: string]: any      // Variables pour interpolation
  }
): string
```

---

## Utilisation

### Import

```astro
---
import { t } from "@/utils/i18n";
---
```

### Traduction Simple

```astro
---
const title = t("sections:about.title", { lng: "fr" });
// ‚Üí "√Ä propos"
---

<h2>{title}</h2>
```

### Traduction avec Interpolation

```astro
---
const name = "Simon";
const phone = "+33 X XX XX XX XX";

const text = t("sections:hero.phoneTitle", {
  lng: "fr",
  name,
  phone
});
// ‚Üí "Contacter Simon au +33 X XX XX XX XX"
---

<a href={`tel:${phone}`} title={text}>
  {phone}
</a>
```

---

## Format des Cl√©s

### Syntaxe : `namespace:path.to.key`

**Namespace** = Nom du fichier JSON (sans `.json`)
**Path** = Chemin dans l'objet JSON (s√©par√© par des points)

#### Exemples

**Fichier** : `public/locales/fr/sections.json`
```json
{
  "hero": {
    "showProfile": "Voir le profil de {{name}} sur"
  },
  "experience": {
    "title": "Exp√©rience professionnelle",
    "now": "Actuel"
  }
}
```

**Utilisation** :
```typescript
t("sections:hero.showProfile", { lng: "fr", name: "Simon" })
// ‚Üí "Voir le profil de Simon sur"

t("sections:experience.title", { lng: "fr" })
// ‚Üí "Exp√©rience professionnelle"

t("sections:experience.now", { lng: "fr" })
// ‚Üí "Actuel"
```

---

## Interpolation de Variables

### Syntaxe : `{{variable}}`

Dans les fichiers JSON, j'utilise `{{nomVariable}}` pour indiquer o√π ins√©rer des donn√©es dynamiques.

**Exemple** :
```json
{
  "hero": {
    "showProfile": "Voir le profil de {{name}} sur",
    "phoneTitle": "Contacter {{name}} au {{phone}}"
  }
}
```

**Code** :
```typescript
t("sections:hero.showProfile", {
  lng: "fr",
  name: "Simon"
});
// ‚Üí "Voir le profil de Simon sur"

t("sections:hero.phoneTitle", {
  lng: "fr",
  name: "Simon",
  phone: "+33 6 12 34 56 78"
});
// ‚Üí "Contacter Simon au +33 6 12 34 56 78"
```

### Fonctionnement Interne

```typescript
// Regex pour trouver toutes les occurrences de {{variable}}
const regex = /\{\{(\w+)\}\}/g;

// Remplacer chaque {{variable}} par sa valeur
translation = translation.replace(regex, (match, varName) => {
  return options[varName] ?? match;
});
```

**Exemple** :
```
Input:  "Voir le profil de {{name}} sur {{network}}"
Options: { name: "Simon", network: "GitHub" }
Output: "Voir le profil de Simon sur GitHub"
```

---

## Fonctionnement Interne

### √âtapes de Traduction

1. **Parse la cl√©** : `"sections:hero.showProfile"`
   - Namespace = `sections`
   - Path = `hero.showProfile`

2. **Charge le fichier JSON** :
   ```typescript
   const translation = await import(
     `/public/locales/${lng}/${namespace}.json`
   );
   ```

3. **Navigate dans l'objet** :
   ```typescript
   let result = translation;
   for (const key of path.split(".")) {
     result = result[key];
   }
   // result = "Voir le profil de {{name}} sur"
   ```

4. **Interpole les variables** :
   ```typescript
   result = result.replace(/\{\{(\w+)\}\}/g, (match, varName) => {
     return options[varName] ?? match;
   });
   // result = "Voir le profil de Simon sur"
   ```

5. **Retourne la string traduite**

---

## Code Source Complet

**Fichier** : `src/utils/i18n.ts`

```typescript
export type Locale = "en" | "fr";

interface TranslationOptions {
  lng: Locale;
  [key: string]: any;
}

// Cache pour √©viter de recharger les m√™mes fichiers
const translationsCache: Record<string, any> = {};

export async function t(
  key: string,
  options: TranslationOptions
): Promise<string> {
  const { lng, ...variables } = options;

  // Parse la cl√© (format: "namespace:path.to.key")
  const [namespace, path] = key.split(":");

  if (!namespace || !path) {
    if (import.meta.env.DEV) {
      console.warn(`Cl√© de traduction invalide: ${key}`);
    }
    return key;
  }

  // V√©rifie que la locale est valide
  if (!["en", "fr"].includes(lng)) {
    if (import.meta.env.DEV) {
      console.warn(`Locale invalide: ${lng}`);
    }
    return key;
  }

  // Charge le fichier de traduction (avec cache)
  const cacheKey = `${lng}-${namespace}`;

  if (!translationsCache[cacheKey]) {
    try {
      const module = await import(
        `/public/locales/${lng}/${namespace}.json`
      );
      translationsCache[cacheKey] = module.default || module;
    } catch (error) {
      if (import.meta.env.DEV) {
        console.warn(
          `Fichier de traduction introuvable: ${lng}/${namespace}.json`
        );
      }
      return key;
    }
  }

  // Navigate dans l'objet JSON avec le path
  let translation = translationsCache[cacheKey];

  for (const segment of path.split(".")) {
    translation = translation?.[segment];

    if (translation === undefined) {
      if (import.meta.env.DEV) {
        console.warn(`Traduction introuvable: ${key}`);
      }
      return key;
    }
  }

  // Interpole les variables
  if (typeof translation === "string") {
    translation = translation.replace(/\{\{(\w+)\}\}/g, (match, varName) => {
      return variables[varName] ?? match;
    });
  }

  return translation;
}

// Version synchrone pour les cas o√π on a d√©j√† charg√© les traductions
export function tSync(key: string, options: TranslationOptions): string {
  // M√™me logique mais sans async/await
  // Utilis√© uniquement si les traductions sont d√©j√† en cache
}
```

---

## Mode DEV vs Production

### Console Warnings

Les warnings ne s'affichent qu'en mode d√©veloppement :

```typescript
if (import.meta.env.DEV) {
  console.warn("Message de debug");
}
```

**En DEV** (`pnpm dev`) :
- ‚úÖ Warnings visibles dans la console
- üêõ Facilite le debugging

**En PROD** (`pnpm build`) :
- ‚úÖ Aucun warning dans la console
- üöÄ Console propre pour l'utilisateur

### Types de Warnings

1. **Cl√© invalide** :
   ```
   Cl√© de traduction invalide: invalidKey
   ```

2. **Locale invalide** :
   ```
   Locale invalide: de
   ```

3. **Fichier introuvable** :
   ```
   Fichier de traduction introuvable: fr/missing.json
   ```

4. **Traduction introuvable** :
   ```
   Traduction introuvable: sections:nonexistent.key
   ```

---

## Cache des Traductions

### Pourquoi un Cache ?

Pour √©viter de recharger les m√™mes fichiers JSON √† chaque appel de `t()`.

```typescript
const translationsCache: Record<string, any> = {};
```

### Cl√© de Cache

Format : `${locale}-${namespace}`

**Exemples** :
- `fr-common`
- `en-sections`
- `fr-components`

### Fonctionnement

```typescript
const cacheKey = `${lng}-${namespace}`;

if (!translationsCache[cacheKey]) {
  // Charge le fichier (1√®re fois seulement)
  const module = await import(`/public/locales/${lng}/${namespace}.json`);
  translationsCache[cacheKey] = module.default || module;
}

// Utilise le cache pour les appels suivants
let translation = translationsCache[cacheKey];
```

**B√©n√©fice** : Performance optimale, chaque fichier n'est charg√© qu'une seule fois.

---

## Ajouter une Nouvelle Traduction

### 1. Identifier le Namespace

- **common** : Textes g√©n√©raux (theme, locale, keyboard)
- **components** : Composants UI (dialog, buttons)
- **sections** : Sections CV (hero, about, experience, etc.)

### 2. Ajouter dans les 2 Langues

**Fran√ßais** (`public/locales/fr/sections.json`) :
```json
{
  "myNewSection": {
    "title": "Mon Nouveau Titre",
    "description": "Description en fran√ßais"
  }
}
```

**Anglais** (`public/locales/en/sections.json`) :
```json
{
  "myNewSection": {
    "title": "My New Title",
    "description": "Description in English"
  }
}
```

### 3. Utiliser dans un Composant

```astro
---
import { t } from "@/utils/i18n";

const { locale } = Astro.props;

const title = t("sections:myNewSection.title", { lng: locale });
const description = t("sections:myNewSection.description", { lng: locale });
---

<h2>{title}</h2>
<p>{description}</p>
```

---

## Bonnes Pratiques

### ‚úÖ Toujours d√©finir dans les 2 langues

```json
// ‚úÖ Bon : FR et EN synchronis√©s
// fr/sections.json
{ "hero": { "title": "H√©ros" } }

// en/sections.json
{ "hero": { "title": "Hero" } }
```

```json
// ‚ùå Mauvais : Manque EN
// fr/sections.json
{ "hero": { "title": "H√©ros" } }

// en/sections.json
{ }  // Vide !
```

### ‚úÖ Utiliser des cl√©s descriptives

```json
// ‚úÖ Bon : Cl√©s explicites
{
  "experience": {
    "showMore": "Voir plus",
    "showLess": "Voir moins"
  }
}

// ‚ùå Mauvais : Cl√©s g√©n√©riques
{
  "btn1": "Voir plus",
  "btn2": "Voir moins"
}
```

### ‚úÖ Grouper logiquement

```json
// ‚úÖ Bon : Regroupement coh√©rent
{
  "hero": {
    "showProfile": "...",
    "phoneTitle": "...",
    "mailTitle": "..."
  }
}

// ‚ùå Mauvais : Tout au m√™me niveau
{
  "heroShowProfile": "...",
  "heroPhoneTitle": "...",
  "heroMailTitle": "..."
}
```

### ‚úÖ Nommer explicitement les variables

```json
// ‚úÖ Bon : Variables explicites
"phoneTitle": "Contacter {{name}} au {{phone}}"

// ‚ùå Mauvais : Variables g√©n√©riques
"phoneTitle": "Contacter {{var1}} au {{var2}}"
```

---

## Debugging

### Tester une Traduction

```astro
---
const test = t("sections:hero.showProfile", {
  lng: "fr",
  name: "Simon"
});

console.log(test);
// ‚Üí "Voir le profil de Simon sur" (si tout va bien)
// ‚Üí "sections:hero.showProfile" (si erreur)
---
```

### V√©rifier les Fichiers JSON

```bash
# Valider la syntaxe
cat public/locales/fr/sections.json | jq .

# Afficher le contenu
jq . public/locales/fr/sections.json
```

### V√©rifier le Cache

En DEV, le cache peut poser probl√®me si on modifie les JSON sans recharger.

**Solution** : Recharger la page compl√®tement (Cmd+R).

---

[‚Üê Sources de Donn√©es](04-sources-donnees.md) | [Retour √† l'index](README.md) | [Circulation des Donn√©es ‚Üí](06-circulation-donnees.md)
